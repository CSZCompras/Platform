{"code":"import { ViewResources } from 'aurelia-templating';\r\nimport { Validator } from '../validator';\r\nimport { ValidateResult } from '../validate-result';\r\nimport { Rules } from './rules';\r\nimport { ValidationMessageProvider } from './validation-messages';\r\n/**\r\n * Validates.\r\n * Responsible for validating objects and properties.\r\n */\r\nexport class StandardValidator extends Validator {\r\n    constructor(messageProvider, resources) {\r\n        super();\r\n        this.messageProvider = messageProvider;\r\n        this.lookupFunctions = resources.lookupFunctions;\r\n        this.getDisplayName = messageProvider.getDisplayName.bind(messageProvider);\r\n    }\r\n    /**\r\n     * Validates the specified property.\r\n     * @param object The object to validate.\r\n     * @param propertyName The name of the property to validate.\r\n     * @param rules Optional. If unspecified, the rules will be looked up using the metadata\r\n     * for the object created by ValidationRules....on(class/object)\r\n     */\r\n    validateProperty(object, propertyName, rules) {\r\n        return this.validate(object, propertyName, rules || null);\r\n    }\r\n    /**\r\n     * Validates all rules for specified object and it's properties.\r\n     * @param object The object to validate.\r\n     * @param rules Optional. If unspecified, the rules will be looked up using the metadata\r\n     * for the object created by ValidationRules....on(class/object)\r\n     */\r\n    validateObject(object, rules) {\r\n        return this.validate(object, null, rules || null);\r\n    }\r\n    /**\r\n     * Determines whether a rule exists in a set of rules.\r\n     * @param rules The rules to search.\r\n     * @parem rule The rule to find.\r\n     */\r\n    ruleExists(rules, rule) {\r\n        let i = rules.length;\r\n        while (i--) {\r\n            if (rules[i].indexOf(rule) !== -1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getMessage(rule, object, value) {\r\n        const expression = rule.message || this.messageProvider.getMessage(rule.messageKey);\r\n        // tslint:disable-next-line:prefer-const\r\n        let { name: propertyName, displayName } = rule.property;\r\n        if (propertyName !== null) {\r\n            displayName = this.messageProvider.getDisplayName(propertyName, displayName);\r\n        }\r\n        const overrideContext = {\r\n            $displayName: displayName,\r\n            $propertyName: propertyName,\r\n            $value: value,\r\n            $object: object,\r\n            $config: rule.config,\r\n            // returns the name of a given property, given just the property name (irrespective of the property's displayName)\r\n            // split on capital letters, first letter ensured to be capitalized\r\n            $getDisplayName: this.getDisplayName\r\n        };\r\n        return expression.evaluate({ bindingContext: object, overrideContext }, this.lookupFunctions);\r\n    }\r\n    validateRuleSequence(object, propertyName, ruleSequence, sequence, results) {\r\n        // are we validating all properties or a single property?\r\n        const validateAllProperties = propertyName === null || propertyName === undefined;\r\n        const rules = ruleSequence[sequence];\r\n        let allValid = true;\r\n        // validate each rule.\r\n        const promises = [];\r\n        for (let i = 0; i < rules.length; i++) {\r\n            const rule = rules[i];\r\n            // is the rule related to the property we're validating.\r\n            // tslint:disable-next-line:triple-equals | Use loose equality for property keys\r\n            if (!validateAllProperties && rule.property.name != propertyName) {\r\n                continue;\r\n            }\r\n            // is this a conditional rule? is the condition met?\r\n            if (rule.when && !rule.when(object)) {\r\n                continue;\r\n            }\r\n            // validate.\r\n            const value = rule.property.name === null ? object : object[rule.property.name];\r\n            let promiseOrBoolean = rule.condition(value, object);\r\n            if (!(promiseOrBoolean instanceof Promise)) {\r\n                promiseOrBoolean = Promise.resolve(promiseOrBoolean);\r\n            }\r\n            promises.push(promiseOrBoolean.then(valid => {\r\n                const message = valid ? null : this.getMessage(rule, object, value);\r\n                results.push(new ValidateResult(rule, object, rule.property.name, valid, message));\r\n                allValid = allValid && valid;\r\n                return valid;\r\n            }));\r\n        }\r\n        return Promise.all(promises)\r\n            .then(() => {\r\n            sequence++;\r\n            if (allValid && sequence < ruleSequence.length) {\r\n                return this.validateRuleSequence(object, propertyName, ruleSequence, sequence, results);\r\n            }\r\n            return results;\r\n        });\r\n    }\r\n    validate(object, propertyName, rules) {\r\n        // rules specified?\r\n        if (!rules) {\r\n            // no. attempt to locate the rules.\r\n            rules = Rules.get(object);\r\n        }\r\n        // any rules?\r\n        if (!rules || rules.length === 0) {\r\n            return Promise.resolve([]);\r\n        }\r\n        return this.validateRuleSequence(object, propertyName, rules, 0, []);\r\n    }\r\n}\r\nStandardValidator.inject = [ValidationMessageProvider, ViewResources];\r\n"}
