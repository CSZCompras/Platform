{"code":"import { LiteralString, Binary, Conditional, LiteralPrimitive, CallMember } from 'aurelia-binding';\r\nimport { BindingLanguage } from 'aurelia-templating';\r\nimport * as LogManager from 'aurelia-logging';\r\nimport { ExpressionVisitor } from './expression-visitor';\r\nexport class ValidationMessageParser {\r\n    constructor(bindinqLanguage) {\r\n        this.bindinqLanguage = bindinqLanguage;\r\n        this.emptyStringExpression = new LiteralString('');\r\n        this.nullExpression = new LiteralPrimitive(null);\r\n        this.undefinedExpression = new LiteralPrimitive(undefined);\r\n        this.cache = {};\r\n    }\r\n    parse(message) {\r\n        if (this.cache[message] !== undefined) {\r\n            return this.cache[message];\r\n        }\r\n        const parts = this.bindinqLanguage.parseInterpolation(null, message);\r\n        if (parts === null) {\r\n            return new LiteralString(message);\r\n        }\r\n        let expression = new LiteralString(parts[0]);\r\n        for (let i = 1; i < parts.length; i += 2) {\r\n            expression = new Binary('+', expression, new Binary('+', this.coalesce(parts[i]), new LiteralString(parts[i + 1])));\r\n        }\r\n        MessageExpressionValidator.validate(expression, message);\r\n        this.cache[message] = expression;\r\n        return expression;\r\n    }\r\n    coalesce(part) {\r\n        // part === null || part === undefined ? '' : part\r\n        return new Conditional(new Binary('||', new Binary('===', part, this.nullExpression), new Binary('===', part, this.undefinedExpression)), this.emptyStringExpression, new CallMember(part, 'toString', []));\r\n    }\r\n}\r\nValidationMessageParser.inject = [BindingLanguage];\r\nexport class MessageExpressionValidator extends ExpressionVisitor {\r\n    constructor(originalMessage) {\r\n        super();\r\n        this.originalMessage = originalMessage;\r\n    }\r\n    static validate(expression, originalMessage) {\r\n        const visitor = new MessageExpressionValidator(originalMessage);\r\n        expression.accept(visitor);\r\n    }\r\n    visitAccessScope(access) {\r\n        if (access.ancestor !== 0) {\r\n            throw new Error('$parent is not permitted in validation message expressions.');\r\n        }\r\n        if (['displayName', 'propertyName', 'value', 'object', 'config', 'getDisplayName'].indexOf(access.name) !== -1) {\r\n            LogManager.getLogger('aurelia-validation')\r\n                // tslint:disable-next-line:max-line-length\r\n                .warn(`Did you mean to use \"$${access.name}\" instead of \"${access.name}\" in this validation message template: \"${this.originalMessage}\"?`);\r\n        }\r\n    }\r\n}\r\n"}
