{"code":"import * as tslib_1 from \"tslib\";\r\nimport { LiteralString, Binary, Conditional, LiteralPrimitive, CallMember } from 'aurelia-binding';\r\nimport { BindingLanguage } from 'aurelia-templating';\r\nimport * as LogManager from 'aurelia-logging';\r\nimport { ExpressionVisitor } from './expression-visitor';\r\nvar ValidationMessageParser = /** @class */ (function () {\r\n    function ValidationMessageParser(bindinqLanguage) {\r\n        this.bindinqLanguage = bindinqLanguage;\r\n        this.emptyStringExpression = new LiteralString('');\r\n        this.nullExpression = new LiteralPrimitive(null);\r\n        this.undefinedExpression = new LiteralPrimitive(undefined);\r\n        this.cache = {};\r\n    }\r\n    ValidationMessageParser.prototype.parse = function (message) {\r\n        if (this.cache[message] !== undefined) {\r\n            return this.cache[message];\r\n        }\r\n        var parts = this.bindinqLanguage.parseInterpolation(null, message);\r\n        if (parts === null) {\r\n            return new LiteralString(message);\r\n        }\r\n        var expression = new LiteralString(parts[0]);\r\n        for (var i = 1; i < parts.length; i += 2) {\r\n            expression = new Binary('+', expression, new Binary('+', this.coalesce(parts[i]), new LiteralString(parts[i + 1])));\r\n        }\r\n        MessageExpressionValidator.validate(expression, message);\r\n        this.cache[message] = expression;\r\n        return expression;\r\n    };\r\n    ValidationMessageParser.prototype.coalesce = function (part) {\r\n        // part === null || part === undefined ? '' : part\r\n        return new Conditional(new Binary('||', new Binary('===', part, this.nullExpression), new Binary('===', part, this.undefinedExpression)), this.emptyStringExpression, new CallMember(part, 'toString', []));\r\n    };\r\n    ValidationMessageParser.inject = [BindingLanguage];\r\n    return ValidationMessageParser;\r\n}());\r\nexport { ValidationMessageParser };\r\nvar MessageExpressionValidator = /** @class */ (function (_super) {\r\n    tslib_1.__extends(MessageExpressionValidator, _super);\r\n    function MessageExpressionValidator(originalMessage) {\r\n        var _this = _super.call(this) || this;\r\n        _this.originalMessage = originalMessage;\r\n        return _this;\r\n    }\r\n    MessageExpressionValidator.validate = function (expression, originalMessage) {\r\n        var visitor = new MessageExpressionValidator(originalMessage);\r\n        expression.accept(visitor);\r\n    };\r\n    MessageExpressionValidator.prototype.visitAccessScope = function (access) {\r\n        if (access.ancestor !== 0) {\r\n            throw new Error('$parent is not permitted in validation message expressions.');\r\n        }\r\n        if (['displayName', 'propertyName', 'value', 'object', 'config', 'getDisplayName'].indexOf(access.name) !== -1) {\r\n            LogManager.getLogger('aurelia-validation')\r\n                // tslint:disable-next-line:max-line-length\r\n                .warn(\"Did you mean to use \\\"$\" + access.name + \"\\\" instead of \\\"\" + access.name + \"\\\" in this validation message template: \\\"\" + this.originalMessage + \"\\\"?\");\r\n        }\r\n    };\r\n    return MessageExpressionValidator;\r\n}(ExpressionVisitor));\r\nexport { MessageExpressionValidator };\r\n"}
