{"code":"import { Rules } from './rules';\r\nimport { validationMessages } from './validation-messages';\r\nimport { isString } from '../util';\r\n/**\r\n * Part of the fluent rule API. Enables customizing property rules.\r\n */\r\nvar FluentRuleCustomizer = /** @class */ (function () {\r\n    function FluentRuleCustomizer(property, condition, config, fluentEnsure, fluentRules, parsers) {\r\n        if (config === void 0) { config = {}; }\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.fluentRules = fluentRules;\r\n        this.parsers = parsers;\r\n        this.rule = {\r\n            property: property,\r\n            condition: condition,\r\n            config: config,\r\n            when: null,\r\n            messageKey: 'default',\r\n            message: null,\r\n            sequence: fluentRules.sequence\r\n        };\r\n        this.fluentEnsure._addRule(this.rule);\r\n    }\r\n    /**\r\n     * Validate subsequent rules after previously declared rules have\r\n     * been validated successfully. Use to postpone validation of costly\r\n     * rules until less expensive rules pass validation.\r\n     */\r\n    FluentRuleCustomizer.prototype.then = function () {\r\n        this.fluentRules.sequence++;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies the key to use when looking up the rule's validation message.\r\n     */\r\n    FluentRuleCustomizer.prototype.withMessageKey = function (key) {\r\n        this.rule.messageKey = key;\r\n        this.rule.message = null;\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies rule's validation message.\r\n     */\r\n    FluentRuleCustomizer.prototype.withMessage = function (message) {\r\n        this.rule.messageKey = 'custom';\r\n        this.rule.message = this.parsers.message.parse(message);\r\n        return this;\r\n    };\r\n    /**\r\n     * Specifies a condition that must be met before attempting to validate the rule.\r\n     * @param condition A function that accepts the object as a parameter and returns true\r\n     * or false whether the rule should be evaluated.\r\n     */\r\n    FluentRuleCustomizer.prototype.when = function (condition) {\r\n        this.rule.when = condition;\r\n        return this;\r\n    };\r\n    /**\r\n     * Tags the rule instance, enabling the rule to be found easily\r\n     * using ValidationRules.taggedRules(rules, tag)\r\n     */\r\n    FluentRuleCustomizer.prototype.tag = function (tag) {\r\n        this.rule.tag = tag;\r\n        return this;\r\n    };\r\n    ///// FluentEnsure APIs /////\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    FluentRuleCustomizer.prototype.ensure = function (subject) {\r\n        return this.fluentEnsure.ensure(subject);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    FluentRuleCustomizer.prototype.ensureObject = function () {\r\n        return this.fluentEnsure.ensureObject();\r\n    };\r\n    Object.defineProperty(FluentRuleCustomizer.prototype, \"rules\", {\r\n        /**\r\n         * Rules that have been defined using the fluent API.\r\n         */\r\n        get: function () {\r\n            return this.fluentEnsure.rules;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    FluentRuleCustomizer.prototype.on = function (target) {\r\n        return this.fluentEnsure.on(target);\r\n    };\r\n    ///////// FluentRules APIs /////////\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    FluentRuleCustomizer.prototype.satisfies = function (condition, config) {\r\n        return this.fluentRules.satisfies(condition, config);\r\n    };\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    FluentRuleCustomizer.prototype.satisfiesRule = function (name) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var _a;\r\n        return (_a = this.fluentRules).satisfiesRule.apply(_a, [name].concat(args));\r\n    };\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    FluentRuleCustomizer.prototype.required = function () {\r\n        return this.fluentRules.required();\r\n    };\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.matches = function (regex) {\r\n        return this.fluentRules.matches(regex);\r\n    };\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.email = function () {\r\n        return this.fluentRules.email();\r\n    };\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.minLength = function (length) {\r\n        return this.fluentRules.minLength(length);\r\n    };\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.maxLength = function (length) {\r\n        return this.fluentRules.maxLength(length);\r\n    };\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.minItems = function (count) {\r\n        return this.fluentRules.minItems(count);\r\n    };\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.maxItems = function (count) {\r\n        return this.fluentRules.maxItems(count);\r\n    };\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRuleCustomizer.prototype.equals = function (expectedValue) {\r\n        return this.fluentRules.equals(expectedValue);\r\n    };\r\n    return FluentRuleCustomizer;\r\n}());\r\nexport { FluentRuleCustomizer };\r\n/**\r\n * Part of the fluent rule API. Enables applying rules to properties and objects.\r\n */\r\nvar FluentRules = /** @class */ (function () {\r\n    function FluentRules(fluentEnsure, parsers, property) {\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.parsers = parsers;\r\n        this.property = property;\r\n        /**\r\n         * Current rule sequence number. Used to postpone evaluation of rules until rules\r\n         * with lower sequence number have successfully validated. The \"then\" fluent API method\r\n         * manages this property, there's usually no need to set it directly.\r\n         */\r\n        this.sequence = 0;\r\n    }\r\n    /**\r\n     * Sets the display name of the ensured property.\r\n     */\r\n    FluentRules.prototype.displayName = function (name) {\r\n        this.property.displayName = name;\r\n        return this;\r\n    };\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    FluentRules.prototype.satisfies = function (condition, config) {\r\n        return new FluentRuleCustomizer(this.property, condition, config, this.fluentEnsure, this, this.parsers);\r\n    };\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    FluentRules.prototype.satisfiesRule = function (name) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var rule = FluentRules.customRules[name];\r\n        if (!rule) {\r\n            // standard rule?\r\n            rule = this[name];\r\n            if (rule instanceof Function) {\r\n                return rule.call.apply(rule, [this].concat(args));\r\n            }\r\n            throw new Error(\"Rule with name \\\"\" + name + \"\\\" does not exist.\");\r\n        }\r\n        var config = rule.argsToConfig ? rule.argsToConfig.apply(rule, args) : undefined;\r\n        return this.satisfies(function (value, obj) {\r\n            var _a;\r\n            return (_a = rule.condition).call.apply(_a, [_this, value, obj].concat(args));\r\n        }, config)\r\n            .withMessageKey(name);\r\n    };\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    FluentRules.prototype.required = function () {\r\n        return this.satisfies(function (value) {\r\n            return value !== null\r\n                && value !== undefined\r\n                && !(isString(value) && !/\\S/.test(value));\r\n        }).withMessageKey('required');\r\n    };\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.matches = function (regex) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || regex.test(value); })\r\n            .withMessageKey('matches');\r\n    };\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.email = function () {\r\n        // regex from https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\r\n        /* tslint:disable:max-line-length */\r\n        return this.matches(/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/)\r\n            /* tslint:enable:max-line-length */\r\n            .withMessageKey('email');\r\n    };\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.minLength = function (length) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || value.length >= length; }, { length: length })\r\n            .withMessageKey('minLength');\r\n    };\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    FluentRules.prototype.maxLength = function (length) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length === 0 || value.length <= length; }, { length: length })\r\n            .withMessageKey('maxLength');\r\n    };\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.minItems = function (count) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length >= count; }, { count: count })\r\n            .withMessageKey('minItems');\r\n    };\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.maxItems = function (count) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value.length <= count; }, { count: count })\r\n            .withMessageKey('maxItems');\r\n    };\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    FluentRules.prototype.equals = function (expectedValue) {\r\n        return this.satisfies(function (value) { return value === null || value === undefined || value === '' || value === expectedValue; }, { expectedValue: expectedValue })\r\n            .withMessageKey('equals');\r\n    };\r\n    FluentRules.customRules = {};\r\n    return FluentRules;\r\n}());\r\nexport { FluentRules };\r\n/**\r\n * Part of the fluent rule API. Enables targeting properties and objects with rules.\r\n */\r\nvar FluentEnsure = /** @class */ (function () {\r\n    function FluentEnsure(parsers) {\r\n        this.parsers = parsers;\r\n        /**\r\n         * Rules that have been defined using the fluent API.\r\n         */\r\n        this.rules = [];\r\n    }\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor\r\n     * function.\r\n     */\r\n    FluentEnsure.prototype.ensure = function (property) {\r\n        this.assertInitialized();\r\n        var name = this.parsers.property.parse(property);\r\n        var fluentRules = new FluentRules(this, this.parsers, { name: name, displayName: null });\r\n        return this.mergeRules(fluentRules, name);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    FluentEnsure.prototype.ensureObject = function () {\r\n        this.assertInitialized();\r\n        var fluentRules = new FluentRules(this, this.parsers, { name: null, displayName: null });\r\n        return this.mergeRules(fluentRules, null);\r\n    };\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    FluentEnsure.prototype.on = function (target) {\r\n        Rules.set(target, this.rules);\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a rule definition to the sequenced ruleset.\r\n     * @internal\r\n     */\r\n    FluentEnsure.prototype._addRule = function (rule) {\r\n        while (this.rules.length < rule.sequence + 1) {\r\n            this.rules.push([]);\r\n        }\r\n        this.rules[rule.sequence].push(rule);\r\n    };\r\n    FluentEnsure.prototype.assertInitialized = function () {\r\n        if (this.parsers) {\r\n            return;\r\n        }\r\n        throw new Error(\"Did you forget to add \\\".plugin('aurelia-validation')\\\" to your main.js?\");\r\n    };\r\n    FluentEnsure.prototype.mergeRules = function (fluentRules, propertyName) {\r\n        // tslint:disable-next-line:triple-equals | Use loose equality for property keys\r\n        var existingRules = this.rules.find(function (r) { return r.length > 0 && r[0].property.name == propertyName; });\r\n        if (existingRules) {\r\n            var rule = existingRules[existingRules.length - 1];\r\n            fluentRules.sequence = rule.sequence;\r\n            if (rule.property.displayName !== null) {\r\n                fluentRules = fluentRules.displayName(rule.property.displayName);\r\n            }\r\n        }\r\n        return fluentRules;\r\n    };\r\n    return FluentEnsure;\r\n}());\r\nexport { FluentEnsure };\r\n/**\r\n * Fluent rule definition API.\r\n */\r\nvar ValidationRules = /** @class */ (function () {\r\n    function ValidationRules() {\r\n    }\r\n    ValidationRules.initialize = function (messageParser, propertyParser) {\r\n        this.parsers = {\r\n            message: messageParser,\r\n            property: propertyParser\r\n        };\r\n    };\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    ValidationRules.ensure = function (property) {\r\n        return new FluentEnsure(ValidationRules.parsers).ensure(property);\r\n    };\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    ValidationRules.ensureObject = function () {\r\n        return new FluentEnsure(ValidationRules.parsers).ensureObject();\r\n    };\r\n    /**\r\n     * Defines a custom rule.\r\n     * @param name The name of the custom rule. Also serves as the message key.\r\n     * @param condition The rule function.\r\n     * @param message The message expression\r\n     * @param argsToConfig A function that maps the rule's arguments to a \"config\"\r\n     * object that can be used when evaluating the message expression.\r\n     */\r\n    ValidationRules.customRule = function (name, condition, message, argsToConfig) {\r\n        validationMessages[name] = message;\r\n        FluentRules.customRules[name] = { condition: condition, argsToConfig: argsToConfig };\r\n    };\r\n    /**\r\n     * Returns rules with the matching tag.\r\n     * @param rules The rules to search.\r\n     * @param tag The tag to search for.\r\n     */\r\n    ValidationRules.taggedRules = function (rules, tag) {\r\n        return rules.map(function (x) { return x.filter(function (r) { return r.tag === tag; }); });\r\n    };\r\n    /**\r\n     * Returns rules that have no tag.\r\n     * @param rules The rules to search.\r\n     */\r\n    ValidationRules.untaggedRules = function (rules) {\r\n        return rules.map(function (x) { return x.filter(function (r) { return r.tag === undefined; }); });\r\n    };\r\n    /**\r\n     * Removes the rules from a class or object.\r\n     * @param target A class or object.\r\n     */\r\n    ValidationRules.off = function (target) {\r\n        Rules.unset(target);\r\n    };\r\n    return ValidationRules;\r\n}());\r\nexport { ValidationRules };\r\n"}
