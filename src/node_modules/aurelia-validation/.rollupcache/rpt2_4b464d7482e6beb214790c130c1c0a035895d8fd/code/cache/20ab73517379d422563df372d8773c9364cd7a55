{"code":"import { Validator } from './validator';\r\nimport { validateTrigger } from './validate-trigger';\r\nimport { getPropertyInfo } from './property-info';\r\nimport { ValidateResult } from './validate-result';\r\nimport { PropertyAccessorParser } from './property-accessor-parser';\r\nimport { ValidateEvent } from './validate-event';\r\n/**\r\n * Orchestrates validation.\r\n * Manages a set of bindings, renderers and objects.\r\n * Exposes the current list of validation results for binding purposes.\r\n */\r\nvar ValidationController = /** @class */ (function () {\r\n    function ValidationController(validator, propertyParser) {\r\n        this.validator = validator;\r\n        this.propertyParser = propertyParser;\r\n        // Registered bindings (via the validate binding behavior)\r\n        this.bindings = new Map();\r\n        // Renderers that have been added to the controller instance.\r\n        this.renderers = [];\r\n        /**\r\n         * Validation results that have been rendered by the controller.\r\n         */\r\n        this.results = [];\r\n        /**\r\n         * Validation errors that have been rendered by the controller.\r\n         */\r\n        this.errors = [];\r\n        /**\r\n         *  Whether the controller is currently validating.\r\n         */\r\n        this.validating = false;\r\n        // Elements related to validation results that have been rendered.\r\n        this.elements = new Map();\r\n        // Objects that have been added to the controller instance (entity-style validation).\r\n        this.objects = new Map();\r\n        /**\r\n         * The trigger that will invoke automatic validation of a property used in a binding.\r\n         */\r\n        this.validateTrigger = validateTrigger.blur;\r\n        // Promise that resolves when validation has completed.\r\n        this.finishValidating = Promise.resolve();\r\n        this.eventCallbacks = [];\r\n    }\r\n    /**\r\n     * Subscribe to controller validate and reset events. These events occur when the\r\n     * controller's \"validate\"\" and \"reset\" methods are called.\r\n     * @param callback The callback to be invoked when the controller validates or resets.\r\n     */\r\n    ValidationController.prototype.subscribe = function (callback) {\r\n        var _this = this;\r\n        this.eventCallbacks.push(callback);\r\n        return {\r\n            dispose: function () {\r\n                var index = _this.eventCallbacks.indexOf(callback);\r\n                if (index === -1) {\r\n                    return;\r\n                }\r\n                _this.eventCallbacks.splice(index, 1);\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     * Adds an object to the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     * @param rules Optional. The rules. If rules aren't supplied the Validator implementation will lookup the rules.\r\n     */\r\n    ValidationController.prototype.addObject = function (object, rules) {\r\n        this.objects.set(object, rules);\r\n    };\r\n    /**\r\n     * Removes an object from the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     */\r\n    ValidationController.prototype.removeObject = function (object) {\r\n        this.objects.delete(object);\r\n        this.processResultDelta('reset', this.results.filter(function (result) { return result.object === object; }), []);\r\n    };\r\n    /**\r\n     * Adds and renders an error.\r\n     */\r\n    ValidationController.prototype.addError = function (message, object, propertyName) {\r\n        if (propertyName === void 0) { propertyName = null; }\r\n        var resolvedPropertyName;\r\n        if (propertyName === null) {\r\n            resolvedPropertyName = propertyName;\r\n        }\r\n        else {\r\n            resolvedPropertyName = this.propertyParser.parse(propertyName);\r\n        }\r\n        var result = new ValidateResult({ __manuallyAdded__: true }, object, resolvedPropertyName, false, message);\r\n        this.processResultDelta('validate', [], [result]);\r\n        return result;\r\n    };\r\n    /**\r\n     * Removes and unrenders an error.\r\n     */\r\n    ValidationController.prototype.removeError = function (result) {\r\n        if (this.results.indexOf(result) !== -1) {\r\n            this.processResultDelta('reset', [result], []);\r\n        }\r\n    };\r\n    /**\r\n     * Adds a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    ValidationController.prototype.addRenderer = function (renderer) {\r\n        var _this = this;\r\n        this.renderers.push(renderer);\r\n        renderer.render({\r\n            kind: 'validate',\r\n            render: this.results.map(function (result) { return ({ result: result, elements: _this.elements.get(result) }); }),\r\n            unrender: []\r\n        });\r\n    };\r\n    /**\r\n     * Removes a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    ValidationController.prototype.removeRenderer = function (renderer) {\r\n        var _this = this;\r\n        this.renderers.splice(this.renderers.indexOf(renderer), 1);\r\n        renderer.render({\r\n            kind: 'reset',\r\n            render: [],\r\n            unrender: this.results.map(function (result) { return ({ result: result, elements: _this.elements.get(result) }); })\r\n        });\r\n    };\r\n    /**\r\n     * Registers a binding with the controller.\r\n     * @param binding The binding instance.\r\n     * @param target The DOM element.\r\n     * @param rules (optional) rules associated with the binding. Validator implementation specific.\r\n     */\r\n    ValidationController.prototype.registerBinding = function (binding, target, rules) {\r\n        this.bindings.set(binding, { target: target, rules: rules, propertyInfo: null });\r\n    };\r\n    /**\r\n     * Unregisters a binding with the controller.\r\n     * @param binding The binding instance.\r\n     */\r\n    ValidationController.prototype.unregisterBinding = function (binding) {\r\n        this.resetBinding(binding);\r\n        this.bindings.delete(binding);\r\n    };\r\n    /**\r\n     * Interprets the instruction and returns a predicate that will identify\r\n     * relevant results in the list of rendered validation results.\r\n     */\r\n    ValidationController.prototype.getInstructionPredicate = function (instruction) {\r\n        var _this = this;\r\n        if (instruction) {\r\n            var object_1 = instruction.object, propertyName_1 = instruction.propertyName, rules_1 = instruction.rules;\r\n            var predicate_1;\r\n            if (instruction.propertyName) {\r\n                predicate_1 = function (x) { return x.object === object_1 && x.propertyName === propertyName_1; };\r\n            }\r\n            else {\r\n                predicate_1 = function (x) { return x.object === object_1; };\r\n            }\r\n            if (rules_1) {\r\n                return function (x) { return predicate_1(x) && _this.validator.ruleExists(rules_1, x.rule); };\r\n            }\r\n            return predicate_1;\r\n        }\r\n        else {\r\n            return function () { return true; };\r\n        }\r\n    };\r\n    /**\r\n     * Validates and renders results.\r\n     * @param instruction Optional. Instructions on what to validate. If undefined, all\r\n     * objects and bindings will be validated.\r\n     */\r\n    ValidationController.prototype.validate = function (instruction) {\r\n        var _this = this;\r\n        // Get a function that will process the validation instruction.\r\n        var execute;\r\n        if (instruction) {\r\n            // tslint:disable-next-line:prefer-const\r\n            var object_2 = instruction.object, propertyName_2 = instruction.propertyName, rules_2 = instruction.rules;\r\n            // if rules were not specified, check the object map.\r\n            rules_2 = rules_2 || this.objects.get(object_2);\r\n            // property specified?\r\n            if (instruction.propertyName === undefined) {\r\n                // validate the specified object.\r\n                execute = function () { return _this.validator.validateObject(object_2, rules_2); };\r\n            }\r\n            else {\r\n                // validate the specified property.\r\n                execute = function () { return _this.validator.validateProperty(object_2, propertyName_2, rules_2); };\r\n            }\r\n        }\r\n        else {\r\n            // validate all objects and bindings.\r\n            execute = function () {\r\n                var promises = [];\r\n                for (var _i = 0, _a = Array.from(_this.objects); _i < _a.length; _i++) {\r\n                    var _b = _a[_i], object = _b[0], rules = _b[1];\r\n                    promises.push(_this.validator.validateObject(object, rules));\r\n                }\r\n                for (var _c = 0, _d = Array.from(_this.bindings); _c < _d.length; _c++) {\r\n                    var _e = _d[_c], binding = _e[0], rules = _e[1].rules;\r\n                    var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n                    if (!propertyInfo || _this.objects.has(propertyInfo.object)) {\r\n                        continue;\r\n                    }\r\n                    promises.push(_this.validator.validateProperty(propertyInfo.object, propertyInfo.propertyName, rules));\r\n                }\r\n                return Promise.all(promises).then(function (resultSets) { return resultSets.reduce(function (a, b) { return a.concat(b); }, []); });\r\n            };\r\n        }\r\n        // Wait for any existing validation to finish, execute the instruction, render the results.\r\n        this.validating = true;\r\n        var returnPromise = this.finishValidating\r\n            .then(execute)\r\n            .then(function (newResults) {\r\n            var predicate = _this.getInstructionPredicate(instruction);\r\n            var oldResults = _this.results.filter(predicate);\r\n            _this.processResultDelta('validate', oldResults, newResults);\r\n            if (returnPromise === _this.finishValidating) {\r\n                _this.validating = false;\r\n            }\r\n            var result = {\r\n                instruction: instruction,\r\n                valid: newResults.find(function (x) { return !x.valid; }) === undefined,\r\n                results: newResults\r\n            };\r\n            _this.invokeCallbacks(instruction, result);\r\n            return result;\r\n        })\r\n            .catch(function (exception) {\r\n            // recover, to enable subsequent calls to validate()\r\n            _this.validating = false;\r\n            _this.finishValidating = Promise.resolve();\r\n            return Promise.reject(exception);\r\n        });\r\n        this.finishValidating = returnPromise;\r\n        return returnPromise;\r\n    };\r\n    /**\r\n     * Resets any rendered validation results (unrenders).\r\n     * @param instruction Optional. Instructions on what to reset. If unspecified all rendered results\r\n     * will be unrendered.\r\n     */\r\n    ValidationController.prototype.reset = function (instruction) {\r\n        var predicate = this.getInstructionPredicate(instruction);\r\n        var oldResults = this.results.filter(predicate);\r\n        this.processResultDelta('reset', oldResults, []);\r\n        this.invokeCallbacks(instruction, null);\r\n    };\r\n    /**\r\n     * Gets the elements associated with an object and propertyName (if any).\r\n     */\r\n    ValidationController.prototype.getAssociatedElements = function (_a) {\r\n        var object = _a.object, propertyName = _a.propertyName;\r\n        var elements = [];\r\n        for (var _i = 0, _b = Array.from(this.bindings); _i < _b.length; _i++) {\r\n            var _c = _b[_i], binding = _c[0], target = _c[1].target;\r\n            var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n            if (propertyInfo && propertyInfo.object === object && propertyInfo.propertyName === propertyName) {\r\n                elements.push(target);\r\n            }\r\n        }\r\n        return elements;\r\n    };\r\n    ValidationController.prototype.processResultDelta = function (kind, oldResults, newResults) {\r\n        // prepare the instruction.\r\n        var instruction = {\r\n            kind: kind,\r\n            render: [],\r\n            unrender: []\r\n        };\r\n        // create a shallow copy of newResults so we can mutate it without causing side-effects.\r\n        newResults = newResults.slice(0);\r\n        var _loop_1 = function (oldResult) {\r\n            // get the elements associated with the old result.\r\n            var elements = this_1.elements.get(oldResult);\r\n            // remove the old result from the element map.\r\n            this_1.elements.delete(oldResult);\r\n            // create the unrender instruction.\r\n            instruction.unrender.push({ result: oldResult, elements: elements });\r\n            // determine if there's a corresponding new result for the old result we are unrendering.\r\n            var newResultIndex = newResults.findIndex(function (x) { return x.rule === oldResult.rule && x.object === oldResult.object && x.propertyName === oldResult.propertyName; });\r\n            if (newResultIndex === -1) {\r\n                // no corresponding new result... simple remove.\r\n                this_1.results.splice(this_1.results.indexOf(oldResult), 1);\r\n                if (!oldResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1);\r\n                }\r\n            }\r\n            else {\r\n                // there is a corresponding new result...\r\n                var newResult = newResults.splice(newResultIndex, 1)[0];\r\n                // get the elements that are associated with the new result.\r\n                var elements_1 = this_1.getAssociatedElements(newResult);\r\n                this_1.elements.set(newResult, elements_1);\r\n                // create a render instruction for the new result.\r\n                instruction.render.push({ result: newResult, elements: elements_1 });\r\n                // do an in-place replacement of the old result with the new result.\r\n                // this ensures any repeats bound to this.results will not thrash.\r\n                this_1.results.splice(this_1.results.indexOf(oldResult), 1, newResult);\r\n                if (!oldResult.valid && newResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1);\r\n                }\r\n                else if (!oldResult.valid && !newResult.valid) {\r\n                    this_1.errors.splice(this_1.errors.indexOf(oldResult), 1, newResult);\r\n                }\r\n                else if (!newResult.valid) {\r\n                    this_1.errors.push(newResult);\r\n                }\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        // create unrender instructions from the old results.\r\n        for (var _i = 0, oldResults_1 = oldResults; _i < oldResults_1.length; _i++) {\r\n            var oldResult = oldResults_1[_i];\r\n            _loop_1(oldResult);\r\n        }\r\n        // create render instructions from the remaining new results.\r\n        for (var _a = 0, newResults_1 = newResults; _a < newResults_1.length; _a++) {\r\n            var result = newResults_1[_a];\r\n            var elements = this.getAssociatedElements(result);\r\n            instruction.render.push({ result: result, elements: elements });\r\n            this.elements.set(result, elements);\r\n            this.results.push(result);\r\n            if (!result.valid) {\r\n                this.errors.push(result);\r\n            }\r\n        }\r\n        // render.\r\n        for (var _b = 0, _c = this.renderers; _b < _c.length; _b++) {\r\n            var renderer = _c[_b];\r\n            renderer.render(instruction);\r\n        }\r\n    };\r\n    /**\r\n     * Validates the property associated with a binding.\r\n     */\r\n    ValidationController.prototype.validateBinding = function (binding) {\r\n        if (!binding.isBound) {\r\n            return;\r\n        }\r\n        var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        var rules;\r\n        var registeredBinding = this.bindings.get(binding);\r\n        if (registeredBinding) {\r\n            rules = registeredBinding.rules;\r\n            registeredBinding.propertyInfo = propertyInfo;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        var object = propertyInfo.object, propertyName = propertyInfo.propertyName;\r\n        this.validate({ object: object, propertyName: propertyName, rules: rules });\r\n    };\r\n    /**\r\n     * Resets the results for a property associated with a binding.\r\n     */\r\n    ValidationController.prototype.resetBinding = function (binding) {\r\n        var registeredBinding = this.bindings.get(binding);\r\n        var propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        if (!propertyInfo && registeredBinding) {\r\n            propertyInfo = registeredBinding.propertyInfo;\r\n        }\r\n        if (registeredBinding) {\r\n            registeredBinding.propertyInfo = null;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        var object = propertyInfo.object, propertyName = propertyInfo.propertyName;\r\n        this.reset({ object: object, propertyName: propertyName });\r\n    };\r\n    /**\r\n     * Changes the controller's validateTrigger.\r\n     * @param newTrigger The new validateTrigger\r\n     */\r\n    ValidationController.prototype.changeTrigger = function (newTrigger) {\r\n        this.validateTrigger = newTrigger;\r\n        var bindings = Array.from(this.bindings.keys());\r\n        for (var _i = 0, bindings_1 = bindings; _i < bindings_1.length; _i++) {\r\n            var binding = bindings_1[_i];\r\n            var source = binding.source;\r\n            binding.unbind();\r\n            binding.bind(source);\r\n        }\r\n    };\r\n    /**\r\n     * Revalidates the controller's current set of errors.\r\n     */\r\n    ValidationController.prototype.revalidateErrors = function () {\r\n        for (var _i = 0, _a = this.errors; _i < _a.length; _i++) {\r\n            var _b = _a[_i], object = _b.object, propertyName = _b.propertyName, rule = _b.rule;\r\n            if (rule.__manuallyAdded__) {\r\n                continue;\r\n            }\r\n            var rules = [[rule]];\r\n            this.validate({ object: object, propertyName: propertyName, rules: rules });\r\n        }\r\n    };\r\n    ValidationController.prototype.invokeCallbacks = function (instruction, result) {\r\n        if (this.eventCallbacks.length === 0) {\r\n            return;\r\n        }\r\n        var event = new ValidateEvent(result ? 'validate' : 'reset', this.errors, this.results, instruction || null, result);\r\n        for (var i = 0; i < this.eventCallbacks.length; i++) {\r\n            this.eventCallbacks[i](event);\r\n        }\r\n    };\r\n    ValidationController.inject = [Validator, PropertyAccessorParser];\r\n    return ValidationController;\r\n}());\r\nexport { ValidationController };\r\n"}
