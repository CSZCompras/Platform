{"code":"import * as tslib_1 from \"tslib\";\r\nimport { bindingMode } from 'aurelia-binding';\r\nimport { Lazy } from 'aurelia-dependency-injection';\r\nimport { customAttribute, bindable } from 'aurelia-templating';\r\nimport { ValidationController } from './validation-controller';\r\nimport { DOM } from 'aurelia-pal';\r\nvar ValidationErrorsCustomAttribute = /** @class */ (function () {\r\n    function ValidationErrorsCustomAttribute(boundaryElement, controllerAccessor) {\r\n        this.boundaryElement = boundaryElement;\r\n        this.controllerAccessor = controllerAccessor;\r\n        this.controller = null;\r\n        this.errors = [];\r\n        this.errorsInternal = [];\r\n    }\r\n    ValidationErrorsCustomAttribute.inject = function () {\r\n        return [DOM.Element, Lazy.of(ValidationController)];\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.sort = function () {\r\n        this.errorsInternal.sort(function (a, b) {\r\n            if (a.targets[0] === b.targets[0]) {\r\n                return 0;\r\n            }\r\n            // tslint:disable-next-line:no-bitwise\r\n            return a.targets[0].compareDocumentPosition(b.targets[0]) & 2 ? 1 : -1;\r\n        });\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.interestingElements = function (elements) {\r\n        var _this = this;\r\n        return elements.filter(function (e) { return _this.boundaryElement.contains(e); });\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.render = function (instruction) {\r\n        var _loop_1 = function (result) {\r\n            var index = this_1.errorsInternal.findIndex(function (x) { return x.error === result; });\r\n            if (index !== -1) {\r\n                this_1.errorsInternal.splice(index, 1);\r\n            }\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, _a = instruction.unrender; _i < _a.length; _i++) {\r\n            var result = _a[_i].result;\r\n            _loop_1(result);\r\n        }\r\n        for (var _b = 0, _c = instruction.render; _b < _c.length; _b++) {\r\n            var _d = _c[_b], result = _d.result, elements = _d.elements;\r\n            if (result.valid) {\r\n                continue;\r\n            }\r\n            var targets = this.interestingElements(elements);\r\n            if (targets.length) {\r\n                this.errorsInternal.push({ error: result, targets: targets });\r\n            }\r\n        }\r\n        this.sort();\r\n        this.errors = this.errorsInternal;\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.bind = function () {\r\n        if (!this.controller) {\r\n            this.controller = this.controllerAccessor();\r\n        }\r\n        // this will call render() with the side-effect of updating this.errors\r\n        this.controller.addRenderer(this);\r\n    };\r\n    ValidationErrorsCustomAttribute.prototype.unbind = function () {\r\n        if (this.controller) {\r\n            this.controller.removeRenderer(this);\r\n        }\r\n    };\r\n    tslib_1.__decorate([\r\n        bindable({ defaultBindingMode: bindingMode.oneWay })\r\n    ], ValidationErrorsCustomAttribute.prototype, \"controller\", void 0);\r\n    tslib_1.__decorate([\r\n        bindable({ primaryProperty: true, defaultBindingMode: bindingMode.twoWay })\r\n    ], ValidationErrorsCustomAttribute.prototype, \"errors\", void 0);\r\n    ValidationErrorsCustomAttribute = tslib_1.__decorate([\r\n        customAttribute('validation-errors')\r\n    ], ValidationErrorsCustomAttribute);\r\n    return ValidationErrorsCustomAttribute;\r\n}());\r\nexport { ValidationErrorsCustomAttribute };\r\n"}
