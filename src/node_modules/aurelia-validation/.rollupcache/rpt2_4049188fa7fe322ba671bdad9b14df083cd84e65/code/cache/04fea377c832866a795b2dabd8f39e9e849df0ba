{"code":"import * as tslib_1 from \"tslib\";\r\nimport { bindingMode } from 'aurelia-binding';\r\nimport { Lazy } from 'aurelia-dependency-injection';\r\nimport { customAttribute, bindable } from 'aurelia-templating';\r\nimport { ValidationController } from './validation-controller';\r\nimport { DOM } from 'aurelia-pal';\r\nlet ValidationErrorsCustomAttribute = class ValidationErrorsCustomAttribute {\r\n    constructor(boundaryElement, controllerAccessor) {\r\n        this.boundaryElement = boundaryElement;\r\n        this.controllerAccessor = controllerAccessor;\r\n        this.controller = null;\r\n        this.errors = [];\r\n        this.errorsInternal = [];\r\n    }\r\n    static inject() {\r\n        return [DOM.Element, Lazy.of(ValidationController)];\r\n    }\r\n    sort() {\r\n        this.errorsInternal.sort((a, b) => {\r\n            if (a.targets[0] === b.targets[0]) {\r\n                return 0;\r\n            }\r\n            // tslint:disable-next-line:no-bitwise\r\n            return a.targets[0].compareDocumentPosition(b.targets[0]) & 2 ? 1 : -1;\r\n        });\r\n    }\r\n    interestingElements(elements) {\r\n        return elements.filter(e => this.boundaryElement.contains(e));\r\n    }\r\n    render(instruction) {\r\n        for (const { result } of instruction.unrender) {\r\n            const index = this.errorsInternal.findIndex(x => x.error === result);\r\n            if (index !== -1) {\r\n                this.errorsInternal.splice(index, 1);\r\n            }\r\n        }\r\n        for (const { result, elements } of instruction.render) {\r\n            if (result.valid) {\r\n                continue;\r\n            }\r\n            const targets = this.interestingElements(elements);\r\n            if (targets.length) {\r\n                this.errorsInternal.push({ error: result, targets });\r\n            }\r\n        }\r\n        this.sort();\r\n        this.errors = this.errorsInternal;\r\n    }\r\n    bind() {\r\n        if (!this.controller) {\r\n            this.controller = this.controllerAccessor();\r\n        }\r\n        // this will call render() with the side-effect of updating this.errors\r\n        this.controller.addRenderer(this);\r\n    }\r\n    unbind() {\r\n        if (this.controller) {\r\n            this.controller.removeRenderer(this);\r\n        }\r\n    }\r\n};\r\ntslib_1.__decorate([\r\n    bindable({ defaultBindingMode: bindingMode.oneWay })\r\n], ValidationErrorsCustomAttribute.prototype, \"controller\", void 0);\r\ntslib_1.__decorate([\r\n    bindable({ primaryProperty: true, defaultBindingMode: bindingMode.twoWay })\r\n], ValidationErrorsCustomAttribute.prototype, \"errors\", void 0);\r\nValidationErrorsCustomAttribute = tslib_1.__decorate([\r\n    customAttribute('validation-errors')\r\n], ValidationErrorsCustomAttribute);\r\nexport { ValidationErrorsCustomAttribute };\r\n"}
