{"code":"import { Rules } from './rules';\r\nimport { validationMessages } from './validation-messages';\r\nimport { isString } from '../util';\r\n/**\r\n * Part of the fluent rule API. Enables customizing property rules.\r\n */\r\nexport class FluentRuleCustomizer {\r\n    constructor(property, condition, config = {}, fluentEnsure, fluentRules, parsers) {\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.fluentRules = fluentRules;\r\n        this.parsers = parsers;\r\n        this.rule = {\r\n            property,\r\n            condition,\r\n            config,\r\n            when: null,\r\n            messageKey: 'default',\r\n            message: null,\r\n            sequence: fluentRules.sequence\r\n        };\r\n        this.fluentEnsure._addRule(this.rule);\r\n    }\r\n    /**\r\n     * Validate subsequent rules after previously declared rules have\r\n     * been validated successfully. Use to postpone validation of costly\r\n     * rules until less expensive rules pass validation.\r\n     */\r\n    then() {\r\n        this.fluentRules.sequence++;\r\n        return this;\r\n    }\r\n    /**\r\n     * Specifies the key to use when looking up the rule's validation message.\r\n     */\r\n    withMessageKey(key) {\r\n        this.rule.messageKey = key;\r\n        this.rule.message = null;\r\n        return this;\r\n    }\r\n    /**\r\n     * Specifies rule's validation message.\r\n     */\r\n    withMessage(message) {\r\n        this.rule.messageKey = 'custom';\r\n        this.rule.message = this.parsers.message.parse(message);\r\n        return this;\r\n    }\r\n    /**\r\n     * Specifies a condition that must be met before attempting to validate the rule.\r\n     * @param condition A function that accepts the object as a parameter and returns true\r\n     * or false whether the rule should be evaluated.\r\n     */\r\n    when(condition) {\r\n        this.rule.when = condition;\r\n        return this;\r\n    }\r\n    /**\r\n     * Tags the rule instance, enabling the rule to be found easily\r\n     * using ValidationRules.taggedRules(rules, tag)\r\n     */\r\n    tag(tag) {\r\n        this.rule.tag = tag;\r\n        return this;\r\n    }\r\n    ///// FluentEnsure APIs /////\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    ensure(subject) {\r\n        return this.fluentEnsure.ensure(subject);\r\n    }\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    ensureObject() {\r\n        return this.fluentEnsure.ensureObject();\r\n    }\r\n    /**\r\n     * Rules that have been defined using the fluent API.\r\n     */\r\n    get rules() {\r\n        return this.fluentEnsure.rules;\r\n    }\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    on(target) {\r\n        return this.fluentEnsure.on(target);\r\n    }\r\n    ///////// FluentRules APIs /////////\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    satisfies(condition, config) {\r\n        return this.fluentRules.satisfies(condition, config);\r\n    }\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    satisfiesRule(name, ...args) {\r\n        return this.fluentRules.satisfiesRule(name, ...args);\r\n    }\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    required() {\r\n        return this.fluentRules.required();\r\n    }\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    matches(regex) {\r\n        return this.fluentRules.matches(regex);\r\n    }\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    email() {\r\n        return this.fluentRules.email();\r\n    }\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    minLength(length) {\r\n        return this.fluentRules.minLength(length);\r\n    }\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    maxLength(length) {\r\n        return this.fluentRules.maxLength(length);\r\n    }\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    minItems(count) {\r\n        return this.fluentRules.minItems(count);\r\n    }\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    maxItems(count) {\r\n        return this.fluentRules.maxItems(count);\r\n    }\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    equals(expectedValue) {\r\n        return this.fluentRules.equals(expectedValue);\r\n    }\r\n}\r\n/**\r\n * Part of the fluent rule API. Enables applying rules to properties and objects.\r\n */\r\nexport class FluentRules {\r\n    constructor(fluentEnsure, parsers, property) {\r\n        this.fluentEnsure = fluentEnsure;\r\n        this.parsers = parsers;\r\n        this.property = property;\r\n        /**\r\n         * Current rule sequence number. Used to postpone evaluation of rules until rules\r\n         * with lower sequence number have successfully validated. The \"then\" fluent API method\r\n         * manages this property, there's usually no need to set it directly.\r\n         */\r\n        this.sequence = 0;\r\n    }\r\n    /**\r\n     * Sets the display name of the ensured property.\r\n     */\r\n    displayName(name) {\r\n        this.property.displayName = name;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies an ad-hoc rule function to the ensured property or object.\r\n     * @param condition The function to validate the rule.\r\n     * Will be called with two arguments, the property value and the object.\r\n     * Should return a boolean or a Promise that resolves to a boolean.\r\n     */\r\n    satisfies(condition, config) {\r\n        return new FluentRuleCustomizer(this.property, condition, config, this.fluentEnsure, this, this.parsers);\r\n    }\r\n    /**\r\n     * Applies a rule by name.\r\n     * @param name The name of the custom or standard rule.\r\n     * @param args The rule's arguments.\r\n     */\r\n    satisfiesRule(name, ...args) {\r\n        let rule = FluentRules.customRules[name];\r\n        if (!rule) {\r\n            // standard rule?\r\n            rule = this[name];\r\n            if (rule instanceof Function) {\r\n                return rule.call(this, ...args);\r\n            }\r\n            throw new Error(`Rule with name \"${name}\" does not exist.`);\r\n        }\r\n        const config = rule.argsToConfig ? rule.argsToConfig(...args) : undefined;\r\n        return this.satisfies((value, obj) => rule.condition.call(this, value, obj, ...args), config)\r\n            .withMessageKey(name);\r\n    }\r\n    /**\r\n     * Applies the \"required\" rule to the property.\r\n     * The value cannot be null, undefined or whitespace.\r\n     */\r\n    required() {\r\n        return this.satisfies(value => value !== null\r\n            && value !== undefined\r\n            && !(isString(value) && !/\\S/.test(value))).withMessageKey('required');\r\n    }\r\n    /**\r\n     * Applies the \"matches\" rule to the property.\r\n     * Value must match the specified regular expression.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    matches(regex) {\r\n        return this.satisfies(value => value === null || value === undefined || value.length === 0 || regex.test(value))\r\n            .withMessageKey('matches');\r\n    }\r\n    /**\r\n     * Applies the \"email\" rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    email() {\r\n        // regex from https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address\r\n        /* tslint:disable:max-line-length */\r\n        return this.matches(/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/)\r\n            /* tslint:enable:max-line-length */\r\n            .withMessageKey('email');\r\n    }\r\n    /**\r\n     * Applies the \"minLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    minLength(length) {\r\n        return this.satisfies((value) => value === null || value === undefined || value.length === 0 || value.length >= length, { length })\r\n            .withMessageKey('minLength');\r\n    }\r\n    /**\r\n     * Applies the \"maxLength\" STRING validation rule to the property.\r\n     * null, undefined and empty-string values are considered valid.\r\n     */\r\n    maxLength(length) {\r\n        return this.satisfies((value) => value === null || value === undefined || value.length === 0 || value.length <= length, { length })\r\n            .withMessageKey('maxLength');\r\n    }\r\n    /**\r\n     * Applies the \"minItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    minItems(count) {\r\n        return this.satisfies((value) => value === null || value === undefined || value.length >= count, { count })\r\n            .withMessageKey('minItems');\r\n    }\r\n    /**\r\n     * Applies the \"maxItems\" ARRAY validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    maxItems(count) {\r\n        return this.satisfies((value) => value === null || value === undefined || value.length <= count, { count })\r\n            .withMessageKey('maxItems');\r\n    }\r\n    /**\r\n     * Applies the \"equals\" validation rule to the property.\r\n     * null and undefined values are considered valid.\r\n     */\r\n    equals(expectedValue) {\r\n        return this.satisfies(value => value === null || value === undefined || value === '' || value === expectedValue, { expectedValue })\r\n            .withMessageKey('equals');\r\n    }\r\n}\r\nFluentRules.customRules = {};\r\n/**\r\n * Part of the fluent rule API. Enables targeting properties and objects with rules.\r\n */\r\nexport class FluentEnsure {\r\n    constructor(parsers) {\r\n        this.parsers = parsers;\r\n        /**\r\n         * Rules that have been defined using the fluent API.\r\n         */\r\n        this.rules = [];\r\n    }\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor\r\n     * function.\r\n     */\r\n    ensure(property) {\r\n        this.assertInitialized();\r\n        const name = this.parsers.property.parse(property);\r\n        const fluentRules = new FluentRules(this, this.parsers, { name, displayName: null });\r\n        return this.mergeRules(fluentRules, name);\r\n    }\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    ensureObject() {\r\n        this.assertInitialized();\r\n        const fluentRules = new FluentRules(this, this.parsers, { name: null, displayName: null });\r\n        return this.mergeRules(fluentRules, null);\r\n    }\r\n    /**\r\n     * Applies the rules to a class or object, making them discoverable by the StandardValidator.\r\n     * @param target A class or object.\r\n     */\r\n    on(target) {\r\n        Rules.set(target, this.rules);\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds a rule definition to the sequenced ruleset.\r\n     * @internal\r\n     */\r\n    _addRule(rule) {\r\n        while (this.rules.length < rule.sequence + 1) {\r\n            this.rules.push([]);\r\n        }\r\n        this.rules[rule.sequence].push(rule);\r\n    }\r\n    assertInitialized() {\r\n        if (this.parsers) {\r\n            return;\r\n        }\r\n        throw new Error(`Did you forget to add \".plugin('aurelia-validation')\" to your main.js?`);\r\n    }\r\n    mergeRules(fluentRules, propertyName) {\r\n        // tslint:disable-next-line:triple-equals | Use loose equality for property keys\r\n        const existingRules = this.rules.find(r => r.length > 0 && r[0].property.name == propertyName);\r\n        if (existingRules) {\r\n            const rule = existingRules[existingRules.length - 1];\r\n            fluentRules.sequence = rule.sequence;\r\n            if (rule.property.displayName !== null) {\r\n                fluentRules = fluentRules.displayName(rule.property.displayName);\r\n            }\r\n        }\r\n        return fluentRules;\r\n    }\r\n}\r\n/**\r\n * Fluent rule definition API.\r\n */\r\nexport class ValidationRules {\r\n    static initialize(messageParser, propertyParser) {\r\n        this.parsers = {\r\n            message: messageParser,\r\n            property: propertyParser\r\n        };\r\n    }\r\n    /**\r\n     * Target a property with validation rules.\r\n     * @param property The property to target. Can be the property name or a property accessor function.\r\n     */\r\n    static ensure(property) {\r\n        return new FluentEnsure(ValidationRules.parsers).ensure(property);\r\n    }\r\n    /**\r\n     * Targets an object with validation rules.\r\n     */\r\n    static ensureObject() {\r\n        return new FluentEnsure(ValidationRules.parsers).ensureObject();\r\n    }\r\n    /**\r\n     * Defines a custom rule.\r\n     * @param name The name of the custom rule. Also serves as the message key.\r\n     * @param condition The rule function.\r\n     * @param message The message expression\r\n     * @param argsToConfig A function that maps the rule's arguments to a \"config\"\r\n     * object that can be used when evaluating the message expression.\r\n     */\r\n    static customRule(name, condition, message, argsToConfig) {\r\n        validationMessages[name] = message;\r\n        FluentRules.customRules[name] = { condition, argsToConfig };\r\n    }\r\n    /**\r\n     * Returns rules with the matching tag.\r\n     * @param rules The rules to search.\r\n     * @param tag The tag to search for.\r\n     */\r\n    static taggedRules(rules, tag) {\r\n        return rules.map(x => x.filter(r => r.tag === tag));\r\n    }\r\n    /**\r\n     * Returns rules that have no tag.\r\n     * @param rules The rules to search.\r\n     */\r\n    static untaggedRules(rules) {\r\n        return rules.map(x => x.filter(r => r.tag === undefined));\r\n    }\r\n    /**\r\n     * Removes the rules from a class or object.\r\n     * @param target A class or object.\r\n     */\r\n    static off(target) {\r\n        Rules.unset(target);\r\n    }\r\n}\r\n"}
