{"code":"import { Validator } from './validator';\r\nimport { validateTrigger } from './validate-trigger';\r\nimport { getPropertyInfo } from './property-info';\r\nimport { ValidateResult } from './validate-result';\r\nimport { PropertyAccessorParser } from './property-accessor-parser';\r\nimport { ValidateEvent } from './validate-event';\r\n/**\r\n * Orchestrates validation.\r\n * Manages a set of bindings, renderers and objects.\r\n * Exposes the current list of validation results for binding purposes.\r\n */\r\nexport class ValidationController {\r\n    constructor(validator, propertyParser) {\r\n        this.validator = validator;\r\n        this.propertyParser = propertyParser;\r\n        // Registered bindings (via the validate binding behavior)\r\n        this.bindings = new Map();\r\n        // Renderers that have been added to the controller instance.\r\n        this.renderers = [];\r\n        /**\r\n         * Validation results that have been rendered by the controller.\r\n         */\r\n        this.results = [];\r\n        /**\r\n         * Validation errors that have been rendered by the controller.\r\n         */\r\n        this.errors = [];\r\n        /**\r\n         *  Whether the controller is currently validating.\r\n         */\r\n        this.validating = false;\r\n        // Elements related to validation results that have been rendered.\r\n        this.elements = new Map();\r\n        // Objects that have been added to the controller instance (entity-style validation).\r\n        this.objects = new Map();\r\n        /**\r\n         * The trigger that will invoke automatic validation of a property used in a binding.\r\n         */\r\n        this.validateTrigger = validateTrigger.blur;\r\n        // Promise that resolves when validation has completed.\r\n        this.finishValidating = Promise.resolve();\r\n        this.eventCallbacks = [];\r\n    }\r\n    /**\r\n     * Subscribe to controller validate and reset events. These events occur when the\r\n     * controller's \"validate\"\" and \"reset\" methods are called.\r\n     * @param callback The callback to be invoked when the controller validates or resets.\r\n     */\r\n    subscribe(callback) {\r\n        this.eventCallbacks.push(callback);\r\n        return {\r\n            dispose: () => {\r\n                const index = this.eventCallbacks.indexOf(callback);\r\n                if (index === -1) {\r\n                    return;\r\n                }\r\n                this.eventCallbacks.splice(index, 1);\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Adds an object to the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     * @param rules Optional. The rules. If rules aren't supplied the Validator implementation will lookup the rules.\r\n     */\r\n    addObject(object, rules) {\r\n        this.objects.set(object, rules);\r\n    }\r\n    /**\r\n     * Removes an object from the set of objects that should be validated when validate is called.\r\n     * @param object The object.\r\n     */\r\n    removeObject(object) {\r\n        this.objects.delete(object);\r\n        this.processResultDelta('reset', this.results.filter(result => result.object === object), []);\r\n    }\r\n    /**\r\n     * Adds and renders an error.\r\n     */\r\n    addError(message, object, propertyName = null) {\r\n        let resolvedPropertyName;\r\n        if (propertyName === null) {\r\n            resolvedPropertyName = propertyName;\r\n        }\r\n        else {\r\n            resolvedPropertyName = this.propertyParser.parse(propertyName);\r\n        }\r\n        const result = new ValidateResult({ __manuallyAdded__: true }, object, resolvedPropertyName, false, message);\r\n        this.processResultDelta('validate', [], [result]);\r\n        return result;\r\n    }\r\n    /**\r\n     * Removes and unrenders an error.\r\n     */\r\n    removeError(result) {\r\n        if (this.results.indexOf(result) !== -1) {\r\n            this.processResultDelta('reset', [result], []);\r\n        }\r\n    }\r\n    /**\r\n     * Adds a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    addRenderer(renderer) {\r\n        this.renderers.push(renderer);\r\n        renderer.render({\r\n            kind: 'validate',\r\n            render: this.results.map(result => ({ result, elements: this.elements.get(result) })),\r\n            unrender: []\r\n        });\r\n    }\r\n    /**\r\n     * Removes a renderer.\r\n     * @param renderer The renderer.\r\n     */\r\n    removeRenderer(renderer) {\r\n        this.renderers.splice(this.renderers.indexOf(renderer), 1);\r\n        renderer.render({\r\n            kind: 'reset',\r\n            render: [],\r\n            unrender: this.results.map(result => ({ result, elements: this.elements.get(result) }))\r\n        });\r\n    }\r\n    /**\r\n     * Registers a binding with the controller.\r\n     * @param binding The binding instance.\r\n     * @param target The DOM element.\r\n     * @param rules (optional) rules associated with the binding. Validator implementation specific.\r\n     */\r\n    registerBinding(binding, target, rules) {\r\n        this.bindings.set(binding, { target, rules, propertyInfo: null });\r\n    }\r\n    /**\r\n     * Unregisters a binding with the controller.\r\n     * @param binding The binding instance.\r\n     */\r\n    unregisterBinding(binding) {\r\n        this.resetBinding(binding);\r\n        this.bindings.delete(binding);\r\n    }\r\n    /**\r\n     * Interprets the instruction and returns a predicate that will identify\r\n     * relevant results in the list of rendered validation results.\r\n     */\r\n    getInstructionPredicate(instruction) {\r\n        if (instruction) {\r\n            const { object, propertyName, rules } = instruction;\r\n            let predicate;\r\n            if (instruction.propertyName) {\r\n                predicate = x => x.object === object && x.propertyName === propertyName;\r\n            }\r\n            else {\r\n                predicate = x => x.object === object;\r\n            }\r\n            if (rules) {\r\n                return x => predicate(x) && this.validator.ruleExists(rules, x.rule);\r\n            }\r\n            return predicate;\r\n        }\r\n        else {\r\n            return () => true;\r\n        }\r\n    }\r\n    /**\r\n     * Validates and renders results.\r\n     * @param instruction Optional. Instructions on what to validate. If undefined, all\r\n     * objects and bindings will be validated.\r\n     */\r\n    validate(instruction) {\r\n        // Get a function that will process the validation instruction.\r\n        let execute;\r\n        if (instruction) {\r\n            // tslint:disable-next-line:prefer-const\r\n            let { object, propertyName, rules } = instruction;\r\n            // if rules were not specified, check the object map.\r\n            rules = rules || this.objects.get(object);\r\n            // property specified?\r\n            if (instruction.propertyName === undefined) {\r\n                // validate the specified object.\r\n                execute = () => this.validator.validateObject(object, rules);\r\n            }\r\n            else {\r\n                // validate the specified property.\r\n                execute = () => this.validator.validateProperty(object, propertyName, rules);\r\n            }\r\n        }\r\n        else {\r\n            // validate all objects and bindings.\r\n            execute = () => {\r\n                const promises = [];\r\n                for (const [object, rules] of Array.from(this.objects)) {\r\n                    promises.push(this.validator.validateObject(object, rules));\r\n                }\r\n                for (const [binding, { rules }] of Array.from(this.bindings)) {\r\n                    const propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n                    if (!propertyInfo || this.objects.has(propertyInfo.object)) {\r\n                        continue;\r\n                    }\r\n                    promises.push(this.validator.validateProperty(propertyInfo.object, propertyInfo.propertyName, rules));\r\n                }\r\n                return Promise.all(promises).then(resultSets => resultSets.reduce((a, b) => a.concat(b), []));\r\n            };\r\n        }\r\n        // Wait for any existing validation to finish, execute the instruction, render the results.\r\n        this.validating = true;\r\n        const returnPromise = this.finishValidating\r\n            .then(execute)\r\n            .then((newResults) => {\r\n            const predicate = this.getInstructionPredicate(instruction);\r\n            const oldResults = this.results.filter(predicate);\r\n            this.processResultDelta('validate', oldResults, newResults);\r\n            if (returnPromise === this.finishValidating) {\r\n                this.validating = false;\r\n            }\r\n            const result = {\r\n                instruction,\r\n                valid: newResults.find(x => !x.valid) === undefined,\r\n                results: newResults\r\n            };\r\n            this.invokeCallbacks(instruction, result);\r\n            return result;\r\n        })\r\n            .catch(exception => {\r\n            // recover, to enable subsequent calls to validate()\r\n            this.validating = false;\r\n            this.finishValidating = Promise.resolve();\r\n            return Promise.reject(exception);\r\n        });\r\n        this.finishValidating = returnPromise;\r\n        return returnPromise;\r\n    }\r\n    /**\r\n     * Resets any rendered validation results (unrenders).\r\n     * @param instruction Optional. Instructions on what to reset. If unspecified all rendered results\r\n     * will be unrendered.\r\n     */\r\n    reset(instruction) {\r\n        const predicate = this.getInstructionPredicate(instruction);\r\n        const oldResults = this.results.filter(predicate);\r\n        this.processResultDelta('reset', oldResults, []);\r\n        this.invokeCallbacks(instruction, null);\r\n    }\r\n    /**\r\n     * Gets the elements associated with an object and propertyName (if any).\r\n     */\r\n    getAssociatedElements({ object, propertyName }) {\r\n        const elements = [];\r\n        for (const [binding, { target }] of Array.from(this.bindings)) {\r\n            const propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n            if (propertyInfo && propertyInfo.object === object && propertyInfo.propertyName === propertyName) {\r\n                elements.push(target);\r\n            }\r\n        }\r\n        return elements;\r\n    }\r\n    processResultDelta(kind, oldResults, newResults) {\r\n        // prepare the instruction.\r\n        const instruction = {\r\n            kind,\r\n            render: [],\r\n            unrender: []\r\n        };\r\n        // create a shallow copy of newResults so we can mutate it without causing side-effects.\r\n        newResults = newResults.slice(0);\r\n        // create unrender instructions from the old results.\r\n        for (const oldResult of oldResults) {\r\n            // get the elements associated with the old result.\r\n            const elements = this.elements.get(oldResult);\r\n            // remove the old result from the element map.\r\n            this.elements.delete(oldResult);\r\n            // create the unrender instruction.\r\n            instruction.unrender.push({ result: oldResult, elements });\r\n            // determine if there's a corresponding new result for the old result we are unrendering.\r\n            const newResultIndex = newResults.findIndex(x => x.rule === oldResult.rule && x.object === oldResult.object && x.propertyName === oldResult.propertyName);\r\n            if (newResultIndex === -1) {\r\n                // no corresponding new result... simple remove.\r\n                this.results.splice(this.results.indexOf(oldResult), 1);\r\n                if (!oldResult.valid) {\r\n                    this.errors.splice(this.errors.indexOf(oldResult), 1);\r\n                }\r\n            }\r\n            else {\r\n                // there is a corresponding new result...\r\n                const newResult = newResults.splice(newResultIndex, 1)[0];\r\n                // get the elements that are associated with the new result.\r\n                const elements = this.getAssociatedElements(newResult);\r\n                this.elements.set(newResult, elements);\r\n                // create a render instruction for the new result.\r\n                instruction.render.push({ result: newResult, elements });\r\n                // do an in-place replacement of the old result with the new result.\r\n                // this ensures any repeats bound to this.results will not thrash.\r\n                this.results.splice(this.results.indexOf(oldResult), 1, newResult);\r\n                if (!oldResult.valid && newResult.valid) {\r\n                    this.errors.splice(this.errors.indexOf(oldResult), 1);\r\n                }\r\n                else if (!oldResult.valid && !newResult.valid) {\r\n                    this.errors.splice(this.errors.indexOf(oldResult), 1, newResult);\r\n                }\r\n                else if (!newResult.valid) {\r\n                    this.errors.push(newResult);\r\n                }\r\n            }\r\n        }\r\n        // create render instructions from the remaining new results.\r\n        for (const result of newResults) {\r\n            const elements = this.getAssociatedElements(result);\r\n            instruction.render.push({ result, elements });\r\n            this.elements.set(result, elements);\r\n            this.results.push(result);\r\n            if (!result.valid) {\r\n                this.errors.push(result);\r\n            }\r\n        }\r\n        // render.\r\n        for (const renderer of this.renderers) {\r\n            renderer.render(instruction);\r\n        }\r\n    }\r\n    /**\r\n     * Validates the property associated with a binding.\r\n     */\r\n    validateBinding(binding) {\r\n        if (!binding.isBound) {\r\n            return;\r\n        }\r\n        const propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        let rules;\r\n        const registeredBinding = this.bindings.get(binding);\r\n        if (registeredBinding) {\r\n            rules = registeredBinding.rules;\r\n            registeredBinding.propertyInfo = propertyInfo;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        const { object, propertyName } = propertyInfo;\r\n        this.validate({ object, propertyName, rules });\r\n    }\r\n    /**\r\n     * Resets the results for a property associated with a binding.\r\n     */\r\n    resetBinding(binding) {\r\n        const registeredBinding = this.bindings.get(binding);\r\n        let propertyInfo = getPropertyInfo(binding.sourceExpression, binding.source);\r\n        if (!propertyInfo && registeredBinding) {\r\n            propertyInfo = registeredBinding.propertyInfo;\r\n        }\r\n        if (registeredBinding) {\r\n            registeredBinding.propertyInfo = null;\r\n        }\r\n        if (!propertyInfo) {\r\n            return;\r\n        }\r\n        const { object, propertyName } = propertyInfo;\r\n        this.reset({ object, propertyName });\r\n    }\r\n    /**\r\n     * Changes the controller's validateTrigger.\r\n     * @param newTrigger The new validateTrigger\r\n     */\r\n    changeTrigger(newTrigger) {\r\n        this.validateTrigger = newTrigger;\r\n        const bindings = Array.from(this.bindings.keys());\r\n        for (const binding of bindings) {\r\n            const source = binding.source;\r\n            binding.unbind();\r\n            binding.bind(source);\r\n        }\r\n    }\r\n    /**\r\n     * Revalidates the controller's current set of errors.\r\n     */\r\n    revalidateErrors() {\r\n        for (const { object, propertyName, rule } of this.errors) {\r\n            if (rule.__manuallyAdded__) {\r\n                continue;\r\n            }\r\n            const rules = [[rule]];\r\n            this.validate({ object, propertyName, rules });\r\n        }\r\n    }\r\n    invokeCallbacks(instruction, result) {\r\n        if (this.eventCallbacks.length === 0) {\r\n            return;\r\n        }\r\n        const event = new ValidateEvent(result ? 'validate' : 'reset', this.errors, this.results, instruction || null, result);\r\n        for (let i = 0; i < this.eventCallbacks.length; i++) {\r\n            this.eventCallbacks[i](event);\r\n        }\r\n    }\r\n}\r\nValidationController.inject = [Validator, PropertyAccessorParser];\r\n"}
